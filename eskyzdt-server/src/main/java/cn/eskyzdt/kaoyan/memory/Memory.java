package cn.eskyzdt.kaoyan.memory;

public class Memory {

    public static void main(String[] args) {
        // 1. 单一连续分配

        // 2. 固定分区分配

        // 3. 动态分区分配
            // -- 动态分区分配算法
            // 1. 首次适应 2.最坏适应 3. 最佳适应 4. 邻近适应
                // 最佳的是首次适应
        // 以上为进程分配 的空间都是连续的
        // 使用的地址都是物理地址
    }

    /**
     * 分页   分配的方式
     * 核心: 上面的方式是进程为一个整体,无法拆开
     *      用分页的方式,把进程所需要的存储空间拆开
     */
    private void fenye() {
        // 动态分区分配会产生一个问题
        // 碎片过多
        // 虽然可以通过紧凑的技术来处理,但是代价高

        // 固定分区分配可以改成非连续分配版本的固定分区分配
        // 例: 有三个均为10MB的分区, 现有一个23MB的进程需要分配空间
        //     那么它被分为10+10+3,产生了7mb的内部碎片
        //     如果分区以2MB来分,那么可用12个分区, 共24MB空间, 产生1MB的内部碎片


    }

    private void definitionOfFrame() {
        // 把内存空间分为一个个大小相等的分区
        // 那么每个分区就叫做 页框
        // 每页有页号,从0开始

        // 将用户进程的   地址空间也分为一个个   与页框 大小相等的分区
        // 称为 页  ,每页有页号 ,从0开始

        // 操作系统以页框为单位为各个进程分配空间
        // 有一一对应的关系

        // 各个页面不必先来后到,可以不用连续,可存入不同的页框中
    }


    /**
     * 页表的构成
     */
    // 进程的页号,找进程的逻辑地址里需要
    private  int[]  页号;
    // 内存的块号,根据块号可以找到内存的物理地址
    private  int[]  块号;


    void applyForFrae() {
        // 进程 按 块  申请内存空间
        // 进程中的块 称为页
        // 内存中的块 称为页框/ 内存块
        //

        // 分页存储结构分为两个部分
        // 高位是页号  低位是页内偏移量

        // 为了记录每页的位置,我们需要   @See 页表

        // 重点: 每个进程都需要一张页表
        //    why?   进程被按页分配了内存空间后, 想找到某个逻辑地址位,需要根据页表
        //          去查询,所以每个进程都需要一个  @See 页表


        // 假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节?
        //
        /**
         * 例
         * 假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节?
         *
         * 4GB= 2^32 B，4KB= 2^12 B
         * 因此4GB的内存总共会被分为2^32/ 2^12= 220个内存块，因此内存块号的范围应该是0~220 -1，
         * 因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够
         */
    }

        void yehao() {
            // 页号从0开始
            // 每页的起始地址为
            // 页号 * 每页的大小

            // 因为上面的原因,页号是可以隐藏的
            // 只要知道页号的起始地址
            // 还有页表项长度
            // 那么可以算出来任意一个页表项的起始地址
            // 如 起始地址是0,每个页表项长度为3, 那么2号页起始地址为,6 (2*3 - 0 )
        }










    void review () {
        //      如 内存总大小 2^32 bit    每页大小2^12 b  即  4kb   则共分2^20 块    页表的页表项的大小2^20b(因为需要对应到内存块(即页框的某个地址),所以需要这么大)
        // 页表一般是存在pcb块中,常驻内存
        // 每个进程的页表都是连续存放的
        // 所以页表是不需要存页表号的
        // 只需要知道页帧表的起始地址和页表项的大小,就可以找到对应页号,再根据页号找到对应的块号,就能找到对应的内存物理地址
        // 再通过物理地址加上地址偏移量,就可以算了




    }





}
